# 为什么 inference 函数需要加锁

## 1. 问题背景

在 `rknn::Model::inference()` 函数中有这样一行代码：

```cpp
rknn::ModelResult rknn::Model::inference(cv::Mat img) {
    std::lock_guard<std::mutex> lock(m_inferenceMtx);  // 为什么需要这个锁？

    m_img = img.clone();
    preprocess();
    rknn_run(m_rknnCtx, nullptr);
    // ...
    return m_result;
}
```

**疑问**：
- 不是已经 3 个线程对应 3 个模型了吗？
- 为什么还需要加锁？
- 每个模型不是只被一个线程使用吗？

---

## 2. 核心问题：任务分配 ≠ 任务执行

### 2.1 任务分配是轮询的

```cpp
// RknnPool::put() 中的任务分配
int modelId = getModelId();  // 轮询分配：0, 1, 2, 0, 1, 2, ...
m_pool->submit(&rknnModel::infer, m_models[modelId], inputData);

// getModelId() 实现
int getModelId() {
    static int id = 0;
    return (id++) % 3;  // 简单轮询
}
```

### 2.2 任务执行是异步的

**关键理解**：任务分配给哪个模型 ≠ 任务由哪个线程执行

```
┌─────────────────────────────────────────────────────────────────┐
│                     任务分配 vs 任务执行                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  任务分配（轮询）：                                               │
│  任务A → Model0                                                  │
│  任务B → Model1                                                  │
│  任务C → Model2                                                  │
│  任务D → Model0  ← 又分配给 Model0                               │
│  任务E → Model1                                                  │
│  任务F → Model2                                                  │
│                                                                 │
│  任务执行（线程池调度）：                                         │
│  - 线程池中的任何空闲线程都可以取走任务                            │
│  - 任务 A 和任务 D 都是 Model0 的任务                             │
│  - 如果 A 执行慢，D 可能被其他线程取走                            │
│  - 两个线程可能同时执行 Model0 的 infer()                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. 问题场景模拟

### 3.1 时间线分析

假设有 3 个线程、3 个模型：

```
时间    操作                          线程池状态
────────────────────────────────────────────────────────────────
T0     提交任务A → Model0            [队列: A]
T1     提交任务B → Model1            [队列: A, B]
T2     提交任务C → Model2            [队列: A, B, C]
T3     线程1取走任务A                 [队列: B, C] 线程1执行Model0
T4     线程2取走任务B                 [队列: C] 线程2执行Model1
T5     线程3取走任务C                 [队列: 空] 线程3执行Model2
T6     提交任务D → Model0            [队列: D]  ← D分配给Model0
T7     提交任务E → Model1            [队列: D, E]
T8     线程2完成任务B，变空闲          线程2从队列取任务...

关键时刻 T8：
- 线程1 还在执行 Model0 的任务A（假设A比较慢）
- 线程2 完成了，从队列取走任务D
- 任务D 是 Model0 的任务！
- 现在 线程1 和 线程2 都要执行 Model0->infer() ！
```

### 3.2 图解

```
                    任务队列
                 ┌─────────────┐
    put(img) ──→ │ D(Model0)   │
                 │ E(Model1)   │
                 └──────┬──────┘
                        │
          ┌─────────────┼─────────────┐
          ▼             ▼             ▼
     ┌─────────┐   ┌─────────┐   ┌─────────┐
     │ 线程 1  │   │ 线程 2  │   │ 线程 3  │
     │ 执行A   │   │ 空闲    │   │ 执行C   │
     │(Model0) │   │ 取走D   │   │(Model2) │
     └────┬────┘   └────┬────┘   └─────────┘
          │             │
          │    任务D是   │
          │   Model0的   │
          ▼             ▼
     ┌─────────────────────────┐
     │        Model 0          │
     │                         │
     │  线程1 → infer(imgA)    │  ← 同时访问！
     │  线程2 → infer(imgD)    │  ← 数据竞争！
     │                         │
     └─────────────────────────┘
```

---

## 4. 不加锁会发生什么？

### 4.1 成员变量被覆盖

```cpp
rknn::ModelResult rknn::Model::inference(cv::Mat img) {
    // 假设没有锁

    m_img = img.clone();      // 问题1：m_img 被覆盖

    preprocess();             // 问题2：处理错误的数据

    rknn_run(m_rknnCtx, ...); // 问题3：RKNN context 状态混乱

    m_result = ...;           // 问题4：结果被覆盖

    return m_result;          // 问题5：返回错误结果
}
```

### 4.2 数据竞争时间线

```
              Model0 的成员变量
              ┌──────────────────────────────────────────────┐
              │  m_img    │  m_rknnCtx  │  m_result          │
              └──────────────────────────────────────────────┘
                   ↑             ↑            ↑
时间 ──────────────────────────────────────────────────────────→

线程1:  m_img = imgA ─────────────────→ preprocess() 读取 m_img
                          ↑                    ↓
线程2:               m_img = imgD         此时 m_img 已经是 imgD！
                                          线程1 处理的是错误数据！

线程1:  ────────────────────────────→ rknn_run()
线程2:  ────────────────────────────→ rknn_run()  ← 同时调用同一个 context！
                                                    RKNN 内部状态混乱！

线程1:  ─────────────────────────────────────→ m_result = resultA
线程2:  ─────────────────────────────────────→ m_result = resultD
                                                    ↑
                                              结果被覆盖！

线程1:  ───────────────────────────────────────────→ return m_result
                                                          ↑
                                                    返回的是 resultD！
```

### 4.3 可能的错误现象

| 错误类型 | 原因 | 表现 |
|---------|------|------|
| **段错误** | RKNN context 被并发访问 | 程序崩溃 |
| **结果错误** | m_result 被覆盖 | 检测结果与输入图片不匹配 |
| **数据混乱** | m_img 被覆盖 | 处理了错误的图片 |
| **随机崩溃** | 内部状态不一致 | 有时正常，有时崩溃 |

---

## 5. 加锁后的执行流程

### 5.1 代码

```cpp
rknn::ModelResult rknn::Model::inference(cv::Mat img) {
    std::lock_guard<std::mutex> lock(m_inferenceMtx);  // 获取锁

    // 以下代码同一时间只有一个线程能执行
    m_img = img.clone();
    preprocess();
    rknn_run(m_rknnCtx, nullptr);
    // ...
    m_result = ...;

    return m_result;
}  // 函数结束，自动释放锁
```

### 5.2 执行时间线

```
线程1 (任务A):  [获取锁] → m_img=imgA → preprocess → rknn_run → m_result=resA → [释放锁]
                                                                                    ↓
线程2 (任务D):  [请求锁] → [等待.................................] → [获取锁] → 正常执行
                    ↑
               线程2 必须等待线程1 完成
               保证了数据的完整性
```

### 5.3 图解

```
┌─────────────────────────────────────────────────────────────────┐
│                      加锁后的执行流程                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  线程1:                                                          │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ [获取锁] ═══ 完整执行 infer(imgA) ═══ [释放锁]           │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                              │                   │
│                                              ▼                   │
│  线程2:                                                          │
│  ┌──────────────────┐    ┌─────────────────────────────────┐    │
│  │ [等待锁........] │ →  │ [获取锁] ═══ 完整执行 infer(imgD) │    │
│  └──────────────────┘    └─────────────────────────────────┘    │
│                                                                 │
│  结果：                                                          │
│  - 线程1 完整处理 imgA，得到正确的 resultA                        │
│  - 线程2 完整处理 imgD，得到正确的 resultD                        │
│  - 两次推理互不干扰                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 6. 常见误解澄清

### 6.1 误解：3线程3模型就是一一对应

**错误理解**：

```
线程1 ←→ Model0（永远绑定）
线程2 ←→ Model1（永远绑定）
线程3 ←→ Model2（永远绑定）
```

**正确理解**：

```
线程池中的线程是通用的，任何线程都可以执行任何任务：

任务队列: [任务A(Model0), 任务B(Model1), 任务C(Model2), 任务D(Model0)]

线程1: 取走任务A → 执行 Model0->infer()
线程2: 取走任务B → 执行 Model1->infer()
线程3: 取走任务C → 执行 Model2->infer()
线程2: (完成B后) 取走任务D → 执行 Model0->infer()  ← 线程2也可以执行Model0的任务！
```

### 6.2 误解：轮询分配能保证安全

**错误理解**：

```
轮询分配：0, 1, 2, 0, 1, 2, ...
所以同一时间每个模型只有一个任务在执行
```

**正确理解**：

```
轮询只决定任务"分配"给哪个模型
不决定任务"何时执行"

任务A(Model0) 可能执行 100ms
任务D(Model0) 可能在 A 还没完成时就开始执行

分配顺序 ≠ 执行顺序
```

### 6.3 误解：只有线程数 > 模型数才需要锁

**错误理解**：

```
3线程3模型：不需要锁
6线程3模型：需要锁
```

**正确理解**：

```
即使 3线程3模型，由于：
1. 任务执行时间不同
2. 线程调度不确定
3. 任务提交速度可能很快

仍然可能出现：
- 同一模型的多个任务同时被不同线程执行
- 必须加锁保护
```

---

## 7. 实验验证

### 7.1 测试代码

```cpp
// 测试：不加锁的情况（危险！仅用于验证问题）
void test_without_lock() {
    // 使用6线程3模型，增加竞争概率
    rknn::RknnPool<detector::YOLO11, cv::Mat, object_detect_result_list> pool(
        model_path, 6, logger::Level::INFO, detect_param);

    cv::Mat img = cv::imread("test.jpg");

    // 快速提交大量任务
    for (int i = 0; i < 100; i++) {
        pool.put(img);
    }

    // 获取结果
    object_detect_result_list result;
    for (int i = 0; i < 100; i++) {
        if (pool.get(result) == 0) {
            std::cout << "Got result " << i << std::endl;
        }
    }
}
```

### 7.2 不加锁的预期结果

```bash
# 可能出现以下情况之一：

# 1. 段错误
Segmentation fault

# 2. RKNN 错误
rknn_run fail! ret=-1

# 3. 随机崩溃
Got result 0
Got result 1
...
Got result 15
Aborted (core dumped)

# 4. 结果错误（难以察觉，最危险）
Got result 0: detected 5 objects  ← 实际应该检测到 10 个
Got result 1: detected 10 objects
...
```

### 7.3 加锁后的预期结果

```bash
# 稳定运行，结果正确
Got result 0: detected 10 objects
Got result 1: detected 10 objects
...
Got result 99: detected 10 objects
```

---

## 8. 总结

### 8.1 为什么需要锁？

| 原因 | 说明 |
|------|------|
| **任务分配 ≠ 任务执行** | 轮询分配不能保证执行顺序 |
| **线程池调度不确定** | 任何空闲线程都可以取走任何任务 |
| **执行时间不同** | 慢任务未完成时，新任务可能开始 |
| **成员变量共享** | 多线程同时访问会导致数据竞争 |

### 8.2 锁保护了什么？

```cpp
class Model {
protected:
    cv::Mat m_img;                              // 被保护
    rknn_context m_rknnCtx;                     // 被保护
    std::unique_ptr<rknn_input[]> m_rknnInputPtr;   // 被保护
    std::unique_ptr<rknn_output[]> m_rknnOutputPtr; // 被保护
    ModelResult m_result;                       // 被保护

    std::mutex m_inferenceMtx;  // 保护上述所有成员变量
};
```

### 8.3 核心理解

```
┌─────────────────────────────────────────────────────────────────┐
│                         核心要点                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 线程池中的线程是"通用工人"                                    │
│     - 不与特定模型绑定                                           │
│     - 谁空闲谁干活                                               │
│                                                                 │
│  2. 任务分配 ≠ 任务执行                                          │
│     - 分配是确定的（轮询）                                        │
│     - 执行是不确定的（取决于线程调度）                             │
│                                                                 │
│  3. 同一模型可能被多个线程同时访问                                 │
│     - 即使 线程数 = 模型数                                        │
│     - 因为执行速度不同                                           │
│                                                                 │
│  4. 锁是必须的                                                   │
│     - 保护成员变量不被并发访问                                    │
│     - 保证每次推理的完整性                                        │
│     - 防止数据竞争和段错误                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 8.4 记忆口诀

```
轮询分配不等于顺序执行，
线程空闲就会抢任务。
同一模型多线程访问，
不加锁保护必出错。
```
